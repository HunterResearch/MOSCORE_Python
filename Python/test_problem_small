#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue May 14 17:29:00 2019

@author: nathangeldner
"""

import numpy as np

import pymoso.chnutils as utils

def create_allocation_problem(obj_vals,obj_vars):
    """Takes in obj_vals, a dictionary of tuples of objective values (other functionsa assume equal length)
    keyed by system number and obj_vars, a dictionary of covariance matrices (numpy matrices) keyed by system number with number
    of rows and columns equal to the number of objectives. returns a dictionary
    with keys "obj" and "var" pointing to obj_vals and obj_var respectively"""
    
    #TODO check for positive semidefinite?
    
    pareto_indices = list(utils.get_nondom(obj_vals))
    
    #I'm not sure if this is necessary, but it was a huge help in debugging so as to keep the pareto_indices
    #in line with the indices used in the matlab code
    pareto_indices.sort(key = lambda x: obj_vals[x][0])
    
    non_pareto_indices = [system for system in range(len(obj_vals)) if system not in pareto_indices]
    #same here
    non_pareto_indices.sort(key = lambda x: obj_vals[x][0])
    
    inv_vars = {}
    
    for i in range(len(obj_vals)):
        obj_vals[i] = np.array(obj_vals[i])
    
    for i in range(len(obj_vars)):
        inv_vars[i] = np.linalg.inv(obj_vars[i])
        
    #for i in range(len(obj_vals)):
    #    obj_vals[i] = obj_vals[i].transpose()
    systems = {"obj": obj_vals, "var": obj_vars, "inv_var": inv_vars, "pareto_indices": pareto_indices, "non_pareto_indices": non_pareto_indices}
    

    
    
    return systems
    
    
def dummy_allocation_problem():
    """This is just for testing, I'm using the 3d example but adding a 4th objective
    that's always zero"""
    
    obj_vals = {0: [8.0, 36.0, 60.0], 1: [12.0, 32.0, 52.0], 2: [14.0, 38.0, 54.0],\
                3: [16.0, 46.0, 48.0], 4: [4.0, 42.0, 56.0], 5: [18.0, 40.0, 62.0], \
             6: [10.0, 44.0, 58.0], 7: [20.0, 34.0, 64.0], 8: [22.0, 28.0, 68.0],\
             }
  
    n_objs = len(obj_vals[0])
    
    this_var = 8.0*8.0
    
    this_corr = 0.85
    
    obj_var = np.array(np.identity(n_objs)*this_var + (np.ones([n_objs,n_objs]) - np.identity(n_objs))*this_corr*this_var)
    
    obj_vars = {}
    
    for i in range(len(obj_vals)):
        obj_vars[i] = obj_var
    
    return create_allocation_problem(obj_vals,obj_vars)
    













